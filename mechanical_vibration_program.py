# -*- coding: utf-8 -*-
"""MVP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TeqmwuV-GnirHtTNO8RuRXh3eX1eKg07
"""

import math
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
import pandas as pd
import sys

def get_float_input(prompt):
    while True:
        try:
            value = float(input(prompt))
            return value
        except ValueError:
            print("Please enter a valid number.")

# Inputs
m = get_float_input("In kg, what is the mass of the oscillating weight?: ")
c = get_float_input("In Ns/m, what is the damping coefficient of the damper?: ")
k = get_float_input("In N/m, what is the spring constant of the spring?: ")
i1 = get_float_input("In m, what is the initial displacement of the weight from equilibrium?: ")
i2 = get_float_input("In m/s, what is the initial velocity of the weight?: ")

# External Force Inputs
include_force = input("Do you want to include an external force? (yes/no): ").strip().lower()
F0 = 0
omega = 0

if include_force == 'yes':
    F0 = get_float_input("In N, what is the amplitude of the external force?: ")
    omega = get_float_input("In rad/s, what is the angular frequency of the external force?: ")
elif include_force == 'no':
    print("No problem.")
else:
    print("Please enter 'yes' or 'no'.")
    sys.exit()

# Discriminant to Determine Vibration Type
dsc = c * c - 4 * m * k
if dsc > 0:
    osctype = "Overdamped Mechanical Vibration"
elif dsc < 0:
    osctype = "Underdamped Mechanical Vibration"
elif dsc == 0:
    osctype = "Critically Damped Mechanical Vibration"

print(f"The system is {osctype}.")

# Differential equation solver function
def equation(t, y):
    x, v = y
    dxdt = v
    dvdt = -(c/m) * v - (k/m) * x + (F0/m) * np.sin(omega * t) if include_force == 'yes' else -(c/m) * v - (k/m) * x
    return [dxdt, dvdt]

# Initial conditions
y0 = [i1, i2]

# Time span for the solution
t_span = (0, 10)  # from t=0 to t=10 seconds
t_eval = np.linspace(t_span[0], t_span[1], 1000)  # 1000 time points for evaluation

# Solve the ODE
sol = solve_ivp(equation, t_span, y0, t_eval=t_eval)

# Calculate energies
displacement = sol.y[0]
velocity = sol.y[1]
potential_energy = 0.5 * k * displacement**2
kinetic_energy = 0.5 * m * velocity**2
total_energy = potential_energy + kinetic_energy

# Save results to CSV
save = input("Would you like to save the following data to a CSV (yes/no)?: ")
if save == "yes":
    results_df = pd.DataFrame({
        'Time (s)': sol.t,
        'Displacement (m)': sol.y[0],
        'Velocity (m/s)': sol.y[1],
        'Potential Energy (J)': potential_energy,
        'Kinetic Energy (J)': kinetic_energy,
        'Total Energy (J)': total_energy
    })
    results_df.to_csv('simulation_results.csv', index=False)
    print("Results saved to 'simulation_results.csv'.")
elif save == "no":
    print("No problem.")

# Plotting the results
plt.figure(figsize=(12, 8))

plt.subplot(2, 1, 1)
plt.plot(sol.t, sol.y[0], label='Displacement (m)')
plt.plot(sol.t, sol.y[1], label='Velocity (m/s)')
plt.xlabel('Time (s)')
plt.ylabel('Response')
plt.legend()
plt.grid()

plt.subplot(2, 1, 2)
plt.plot(sol.t, total_energy, label='Total Energy (J)')
plt.xlabel('Time (s)')
plt.ylabel('Energy (J)')
plt.legend()
plt.grid()

plt.suptitle('Mechanical Vibration System Response')
plt.tight_layout()
plt.show()

# Fourier Transform of the Displacement
n = len(displacement)
dt = t_eval[1] - t_eval[0]
frequencies = np.fft.fftfreq(n, dt)
fft_displacement = np.fft.fft(displacement)

# Plot the Fourier Transform
plt.figure(figsize=(12, 6))
plt.plot(frequencies[:n//2], np.abs(fft_displacement)[:n//2])
plt.title('Fourier Transform of the Displacement')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude')
plt.grid()
plt.show()
